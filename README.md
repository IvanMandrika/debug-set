# Реализация отладочного множества (debug_set)

Проект предоставляет реализацию бинарного дерева поиска с расширенными проверками корректности операций.  
Класс `debug_set` повторяет интерфейс `std::set` и добавляет детекцию некорректных действий для отладки.

## Основные особенности
### Семантика операций
- Полная совместимость с интерфейсом `std::set`
- Гарантированная сложность операций:
  - Вставка, удаление, поиск: **O(h)**, где h — высота дерева
  - Полный обход: **O(n)** (суммарно для `begin()` → `end()`)
- Память: Пустой `debug_set` не аллоцирует динамическую память.

### Отладочные проверки
Программа завершается через `abort()` при:
1. Разыменовании/инкременте/декременте невалидного итератора
2. Разыменовании `end()`
3. Инкременте `end()`
4. Декременте `begin()`
5. Удалении элемента через `end()`

### Гарантии безопасности
- **Вставка**: Не инвалидирует итераторы
- **Удаление**: Инвалидирует только итераторы на удаляемые элементы
- **Итератор `end()`**: Всегда остаётся валидным
- **Исключения**: Гарантии безопасности соответствуют `std::set`, кроме:
  - `begin()`, `end()`, `swap()`
  - Копирование/присваивание итераторов (слабые гарантии)

## Использование
```cpp
#include "set.h"

int main() {
    debug_set<int> s;
    s.insert(10);
    s.insert(20);
    
    // Пример корректного удаления
    auto it = s.find(20);
    if (it != s.end()) {
        s.erase(it); // OK
    }
    
    // Некорректные действия (приведут к abort()):
    // s.erase(s.end());       // Попытка удаления через end()
    // debug_set<int>::iterator invalid;
    // ++invalid;              // Инкремент невалидного итератора
    return 0;
}
```

## Архитектура

- Итераторы: Реализованы через фейковую вершину для обработки граничных условий, тип – bidirectional.
- Узлы дерева: Хранят ссылки на родителя и дочерние элементы для поддержки операций ++/--.
- Валидация итераторов: Каждый итератор отслеживает своё состояние и принадлежность контейнеру.
